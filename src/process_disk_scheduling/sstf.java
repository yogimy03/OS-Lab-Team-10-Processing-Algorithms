/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package process_disk_scheduling;

import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import static java.lang.Math.abs;
import java.util.*;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartFrame;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.labels.ItemLabelAnchor;
import org.jfree.chart.labels.ItemLabelPosition;
import org.jfree.chart.labels.StandardCategoryItemLabelGenerator;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PiePlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.renderer.category.LineAndShapeRenderer;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.data.general.DefaultPieDataset;
import org.jfree.ui.TextAnchor;

/**
 *
 * @author Sanskar Bhuwania
 */
public class sstf extends javax.swing.JFrame {
    DefaultTableModel tbmodel;
    /**
     * Creates new form sstf
     */
    public sstf() {
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        compute = new javax.swing.JButton();
        close = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        head = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        request = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        delete = new javax.swing.JButton();
        add = new javax.swing.JButton();
        seek_time = new javax.swing.JTextField();
        seek_sequence = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        disk_size = new javax.swing.JTextField();
        graph = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(0, 102, 102));
        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 15));

        jLabel1.setFont(new java.awt.Font("Comic Sans MS", 3, 24)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(255, 255, 255));
        jLabel1.setText("SSTF SCHEDULING ALGORITHM");

        compute.setFont(new java.awt.Font("Comic Sans MS", 0, 12)); // NOI18N
        compute.setText("Compute");
        compute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                computeActionPerformed(evt);
            }
        });

        close.setFont(new java.awt.Font("Comic Sans MS", 0, 12)); // NOI18N
        close.setText("Close");
        close.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeActionPerformed(evt);
            }
        });

        jLabel2.setFont(new java.awt.Font("Comic Sans MS", 0, 14)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(255, 255, 255));
        jLabel2.setText("Enter the Intial Head position: ");

        head.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                headActionPerformed(evt);
            }
        });

        jLabel3.setFont(new java.awt.Font("Comic Sans MS", 0, 14)); // NOI18N
        jLabel3.setForeground(new java.awt.Color(255, 255, 255));
        jLabel3.setText("Enter the Disk Request sequence: ");

        request.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                requestActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Comic Sans MS", 0, 14)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(255, 255, 255));
        jLabel4.setText("Total Seek Time is: ");

        jLabel5.setFont(new java.awt.Font("Comic Sans MS", 0, 14)); // NOI18N
        jLabel5.setForeground(new java.awt.Color(255, 255, 255));
        jLabel5.setText("Seek Sequence is: ");

        jTable1.setFont(new java.awt.Font("Comic Sans MS", 0, 12)); // NOI18N
        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Disk Request Sequence"
            }
        ));
        jScrollPane1.setViewportView(jTable1);

        delete.setFont(new java.awt.Font("Comic Sans MS", 0, 12)); // NOI18N
        delete.setText("Delete");
        delete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deleteActionPerformed(evt);
            }
        });

        add.setFont(new java.awt.Font("Comic Sans MS", 0, 12)); // NOI18N
        add.setText("Add");
        add.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addActionPerformed(evt);
            }
        });

        seek_sequence.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                seek_sequenceActionPerformed(evt);
            }
        });

        jLabel6.setFont(new java.awt.Font("Comic Sans MS", 0, 14)); // NOI18N
        jLabel6.setForeground(new java.awt.Color(255, 255, 255));
        jLabel6.setText("Enter the Disk Size:");

        graph.setFont(new java.awt.Font("Comic Sans MS", 0, 12)); // NOI18N
        graph.setText("Graph");
        graph.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                graphActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel4)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(seek_time, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(seek_sequence, javax.swing.GroupLayout.PREFERRED_SIZE, 291, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3)
                                    .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(jPanel1Layout.createSequentialGroup()
                                        .addComponent(head, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(18, 18, 18)
                                        .addComponent(jLabel6)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(disk_size, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(jPanel1Layout.createSequentialGroup()
                                        .addComponent(request, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(18, 18, 18)
                                        .addComponent(add, javax.swing.GroupLayout.PREFERRED_SIZE, 79, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                        .addGap(0, 53, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addGap(0, 132, Short.MAX_VALUE)
                        .addComponent(jLabel1)
                        .addGap(129, 129, 129))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 129, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(close, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGap(38, 38, 38)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(compute, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(delete, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(graph, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(close)
                        .addContainerGap())
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(33, 33, 33)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jLabel6)
                                .addComponent(disk_size, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(head, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jLabel2)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel3)
                            .addComponent(request, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(add))
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(37, 37, 37)
                                .addComponent(delete)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(compute)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(graph))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 149, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 19, Short.MAX_VALUE)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel4)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jLabel5))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(seek_time, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(seek_sequence, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(30, 30, 30))))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void computeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_computeActionPerformed
        // TODO add your handling code here:
        if (head.getText().equals("") || jTable1.getRowCount()==0) {
            JOptionPane.showMessageDialog(this,"One or more fields are empty.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        else if (Integer.parseInt(head.getText()) > Integer.parseInt(disk_size.getText())) {
            JOptionPane.showMessageDialog(this,"Intial head position cannot be greater than Disk size.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        else {
            
            class node {
                int distance = 0;
                boolean accessed = false;
            }
            
            int size = jTable1.getRowCount();
            int arr[] = new int[size];
            int h = Integer.parseInt(head.getText());
            
            node diff[] = new node[size];
            
            for (int i=0; i<diff.length; i++)
                diff[i] = new node();
            
            int seek_count = 0;
            int seek[] = new int[size+1];
            
            for (int i=0; i<size; i++) {
                seek[i] = h;
                
                for (int j = 0; j < diff.length; j++) {
                    arr[j] = Integer.parseInt(jTable1.getValueAt(j,0).toString());
                    diff[j].distance = Math.abs(arr[j] - h);
                }
                
                int index = -1, minimum = Integer.MAX_VALUE; 
  
                for (int k = 0; k < diff.length; k++) { 
                    if (!diff[k].accessed && minimum > diff[k].distance) {  
                        minimum = diff[k].distance; 
                        index = k; 
                    } 
                } 
                
                diff[index].accessed = true; 
                seek_count += diff[index].distance;  
                h = arr[index];
            }
            seek[seek.length - 1] =h;
            seek_time.setText(Integer.toString(seek_count));
            seek_sequence.setText(Arrays.toString(seek));  
        } 
    }//GEN-LAST:event_computeActionPerformed

    private void closeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeActionPerformed
        // TODO add your handling code here:
        //this.setVisible(false);
        dispose();
    }//GEN-LAST:event_closeActionPerformed

    private void requestActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_requestActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_requestActionPerformed

    private void deleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteActionPerformed
        // TODO add your handling code here:
        tbmodel.removeRow(jTable1.getSelectedRow());
    }//GEN-LAST:event_deleteActionPerformed

    private void headActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_headActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_headActionPerformed

    private void addActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addActionPerformed
        // TODO add your handling code here:
        if (request.getText().equals("")) {
            JOptionPane.showMessageDialog(this,"Enter the Disk Request.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        else if (disk_size.getText().equals("")) {
            JOptionPane.showMessageDialog(this,"Enter the Disk Size.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        else if (Integer.parseInt(request.getText()) > Integer.parseInt(disk_size.getText())) {
            JOptionPane.showMessageDialog(this,"Disk Request cannot be greater than Disk Size.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        else {
            tbmodel = (DefaultTableModel)jTable1.getModel();
            tbmodel.addRow(new Object[] {request.getText()});
            request.setText("");
        } 
    }//GEN-LAST:event_addActionPerformed

    private void seek_sequenceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_seek_sequenceActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_seek_sequenceActionPerformed

    private void graphActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_graphActionPerformed
        // TODO add your handling code here:
        if (head.getText().equals("") || jTable1.getRowCount()==0) {
            JOptionPane.showMessageDialog(this,"One or more fields are empty.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        else if (Integer.parseInt(head.getText()) > Integer.parseInt(disk_size.getText())) {
            JOptionPane.showMessageDialog(this,"Intial head position cannot be greater than Disk size.", "Error", JOptionPane.ERROR_MESSAGE);
        }
        else {
            DefaultCategoryDataset dataset = new DefaultCategoryDataset();
            class node {
                int distance = 0;
                boolean accessed = false;
            }
            
            int size = jTable1.getRowCount();
            int arr[] = new int[size];
            int h = Integer.parseInt(head.getText());
            
            node diff[] = new node[size];
            
            for (int i=0; i<diff.length; i++)
                diff[i] = new node();
            
            int seek_count = 0;
            int seek[] = new int[size+1];
            
            for (int i=0; i<size; i++) {
                seek[i] = h;
                
                for (int j = 0; j < diff.length; j++) {
                    arr[j] = Integer.parseInt(jTable1.getValueAt(j,0).toString());
                    diff[j].distance = Math.abs(arr[j] - h);
                }
                
                int index = -1, minimum = Integer.MAX_VALUE; 
  
                for (int k = 0; k < diff.length; k++) { 
                    if (!diff[k].accessed && minimum > diff[k].distance) {  
                        minimum = diff[k].distance; 
                        index = k; 
                    } 
                } 
                
                diff[index].accessed = true; 
                seek_count += diff[index].distance;  
                h = arr[index];
            }
            
            seek[seek.length - 1] =h;
            for (int i=0 ; i<seek.length; i++) {
                dataset.addValue ((Number) seek[i],"Process",i+1);
            }

            JFreeChart chart = ChartFactory.createLineChart("SSTF Disk Scheduling", "", "Disk Request", dataset, PlotOrientation.HORIZONTAL, true, true, false);
            CategoryPlot p = chart.getCategoryPlot();
            p.setRangeGridlinePaint(Color.black);
            NumberAxis axis = (NumberAxis)p.getRangeAxis();
            axis.setAutoRange(false);
            axis.setRange(0,Integer.parseInt(disk_size.getText()));
            ChartFrame frame = new ChartFrame("", chart);
            JButton b = new JButton ("Save");
            JButton a = new JButton ("Compare All");
            frame.setLayout(null);
            b.setBounds (625, 378, 70, 27);
            a.setBounds (298, 378, 95, 27);
            frame.add(b);
            frame.add(a);
            frame.setVisible(true);
            frame.setSize(720, 442);
            frame.setLocationRelativeTo(null);
            
            LineAndShapeRenderer lineRender = new LineAndShapeRenderer();
            lineRender.setBaseItemLabelGenerator(new StandardCategoryItemLabelGenerator());
            lineRender.setBaseItemLabelsVisible(true);
            lineRender.setBasePositiveItemLabelPosition(
            new ItemLabelPosition(ItemLabelAnchor.OUTSIDE12, TextAnchor.BASELINE_CENTER));
            p.setRenderer(lineRender);
            
            b.addActionListener(new ActionListener(){  
                public void actionPerformed(ActionEvent e){  
                    String checkInput = JOptionPane.showInputDialog(null, "Enter the file name to save your graph: ");

                    if (checkInput != null){
                        try {
                            ChartUtilities.saveChartAsPNG(new File(checkInput+".jpg"), chart, 600, 300); 
                            JOptionPane.showMessageDialog(null, "Image successfully saved!", "Success", JOptionPane.INFORMATION_MESSAGE);
                        } 
                        catch (Exception ex) {
                            JOptionPane.showMessageDialog(null,"Image failed to save.", "Error", JOptionPane.ERROR_MESSAGE);
                        }
                    }
                     else{
                        System.out.println("");
                    }
                }  
            });
            
            a.addActionListener(new ActionListener(){  
                public void actionPerformed(ActionEvent e){
                    DefaultPieDataset dataset = new DefaultPieDataset();
                    int size = jTable1.getRowCount();
                    
                //FCFS
                {
                    int arr[] = new int[size];
                    int seek_count = 0;
                    int distance, cur_track;
                    int h = Integer.parseInt(head.getText());
                    
                    for (int i=0; i<size; i++) {
                        arr[i] = Integer.parseInt(jTable1.getValueAt(i,0).toString());
                        cur_track = arr[i]; 
                        distance = Math.abs(cur_track - h); 
                        seek_count += distance; 
                        h = cur_track;  
                    }
                    dataset.setValue ("FCFS",(Number)seek_count);
                }    
                    
                //SSTF
                {
                    class node {
                    int distance = 0;
                    boolean accessed = false;
                    }

                    int arr_1[] = new int[size];
                    int h_1 = Integer.parseInt(head.getText());
                    node diff[] = new node[size];

                    for (int i=0; i<diff.length; i++)
                        diff[i] = new node();

                    int seek_count_1 = 0;
                    int seek_1[] = new int[size+1];

                    for (int i=0; i<size; i++) {
                        seek_1[i] = h_1;

                        for (int j = 0; j < diff.length; j++) {
                            arr_1[j] = Integer.parseInt(jTable1.getValueAt(j,0).toString());
                            diff[j].distance = Math.abs(arr_1[j] - h_1);
                        }

                        int index = -1, minimum = Integer.MAX_VALUE; 

                        for (int k = 0; k < diff.length; k++) { 
                            if (!diff[k].accessed && minimum > diff[k].distance) {  
                                minimum = diff[k].distance; 
                                index = k; 
                            } 
                        } 

                        diff[index].accessed = true; 
                        seek_count_1 += diff[index].distance;  
                        h_1 = arr_1[index];
                    }
                    dataset.setValue ("SSTF",(Number)seek_count_1);
                }
                
                //SCAN-Left
                {
                    int h_2 = Integer.parseInt(head.getText());
                    int disk_2 = Integer.parseInt(disk_size.getText());
                    String direction_2 = "left";
                    int arr_2[] = new int[size];
                    int seek_count_2 = 0;
                    int distance_2, cur_track_2;

                    Vector<Integer> left_2 = new Vector<Integer>(), right_2 = new Vector<Integer>();
                    Vector<Integer> seek_2 = new Vector<Integer>();

                    left_2.add(0);

                    for (int i=0; i<size; i++) {
                        arr_2[i] = Integer.parseInt(jTable1.getValueAt(i,0).toString());
                        if (arr_2[i] < h_2)
                            left_2.add(arr_2[i]);
                        if (arr_2[i] > h_2)
                            right_2.add(arr_2[i]);
                    }

                    Collections.sort(left_2);
                    Collections.sort(right_2);

                    int run_2 = 2;
                    while (run_2-- >0)
                    {
                        if (direction_2 == "left") 
                        {
                            for (int i = left_2.size() - 1; i >= 0; i--) 
                            {
                                cur_track_2 = left_2.get(i);
                                seek_2.add(cur_track_2);
                                distance_2 = Math.abs(cur_track_2 - h_2);
                                seek_count_2 += distance_2;
                                h_2 = cur_track_2;
                            }
                            direction_2 = "right";
                        }
                        else if (direction_2 == "right") 
                        {
                            for (int i = 0; i < right_2.size(); i++) 
                            {
                                cur_track_2 = right_2.get(i);
                                seek_2.add(cur_track_2);
                                distance_2 = Math.abs(cur_track_2 - h_2);
                                seek_count_2 += distance_2;
                                h_2 = cur_track_2;
                            }
                            direction_2 = "left";
                        }
                    }
                    dataset.setValue ("SCAN_Left",(Number)seek_count_2);
                }
                
                //SCAN-Right
                {
                    int h_3 = Integer.parseInt(head.getText());
                    int disk_3 = Integer.parseInt(disk_size.getText());
                    String direction_3 = "right";
                    int arr_3[] = new int[size];
                    int seek_count_3 = 0;
                    int distance_3, cur_track_3;

                    Vector<Integer> left_3 = new Vector<Integer>(), right_3 = new Vector<Integer>();
                    Vector<Integer> seek_3 = new Vector<Integer>();

                    right_3.add(disk_3-1);

                    for (int i=0; i<size; i++) {
                        arr_3[i] = Integer.parseInt(jTable1.getValueAt(i,0).toString());
                        if (arr_3[i] < h_3)
                            left_3.add(arr[i]);
                        if (arr_3[i] > h_3)
                            right_3.add(arr_3[i]);
                    }

                    Collections.sort(left_3);
                    Collections.sort(right_3);

                    int run_3 = 2;
                    while (run_3-- >0)
                    {
                        if (direction_3 == "left") 
                        {
                            for (int i = left_3.size() - 1; i >= 0; i--) 
                            {
                                cur_track_3 = left_3.get(i);
                                seek_3.add(cur_track_3);
                                distance_3 = Math.abs(cur_track_3 - h_3);
                                seek_count_3 += distance_3;
                                h_3 = cur_track_3;
                            }
                            direction_3 = "right";
                        }
                        else if (direction_3 == "right") 
                        {
                            for (int i = 0; i < right_3.size(); i++) 
                            {
                                cur_track_3 = right_3.get(i);
                                seek_3.add(cur_track_3);
                                distance_3 = Math.abs(cur_track_3 - h_3);
                                seek_count_3 += distance_3;
                                h_3 = cur_track_3;
                            }
                            direction_3 = "left";
                        }
                    }
                    dataset.setValue ("SCAN_Right",(Number)seek_count_3);
                }    
                    
                //C-SCAN-Left
                {
                    int h_4 = Integer.parseInt(head.getText());
                    int disk_4 = Integer.parseInt(disk_size.getText());
                    int arr_4[] = new int[size];
                    int seek_count_4 = 0;
                    int distance_4, cur_track_4;
                    String direction_4 = "left";

                    Vector<Integer> left_4 = new Vector<Integer>(), right_4 = new Vector<Integer>();
                    Vector<Integer> seek_4 = new Vector<Integer>();

                    left_4.add(0);
                    right_4.add(disk_4-1);

                    for (int i=0; i<size; i++) {
                        arr_4[i] = Integer.parseInt(jTable1.getValueAt(i,0).toString());
                        if (arr_4[i] < h_4)
                            left_4.add(arr_4[i]);
                        if (arr_4[i] > h_4)
                            right_4.add(arr_4[i]);
                    }

                    Collections.sort(left_4);
                    Collections.sort(right_4);

                    if (direction_4 == "left") {
                        for (int i = left_4.size() - 1; i >= 0; i--)
                        {
                            cur_track_4 = left_4.get(i);
                            seek_4.add(cur_track_4);
                            distance_4 = Math.abs(cur_track_4 - h_4);
                            seek_count_4 += distance_4;
                            h_4 = cur_track_4;
                        }
                        h_4 = disk_4-1;
                        for (int i = right_4.size() - 1; i >= 0; i--)
                        {
                            cur_track_4 = right_4.get(i);
                            seek_4.add(cur_track_4);
                            distance_4 = Math.abs(cur_track_4 - h_4);
                            seek_count_4 += distance_4;
                            h_4 = cur_track_4;
                        }
                    }
                    else if (direction_4 == "right") {
                        for (int i = 0; i < right_4.size(); i++) 
                        {
                            cur_track_4 = right_4.get(i);
                            seek_4.add(cur_track_4);
                            distance_4 = Math.abs(cur_track_4 - h_4);
                            seek_count_4 += distance_4;
                            h_4 = cur_track_4;
                        }
                        h_4 = 0;
                        for (int i =0; i< left_4.size(); i++) 
                        {
                            cur_track_4 = left_4.get(i);
                            seek_4.add(cur_track_4);
                            distance_4 = Math.abs(cur_track_4 - h_4);
                            seek_count_4 += distance_4;
                            h_4 = cur_track_4;
                        }
                    }

                    seek_count_4+=199;
                    dataset.setValue ("C-SCAN_Left",(Number)seek_count_4);
                }
                
                //C-SCAN-Right    
                {
                    int h_5 = Integer.parseInt(head.getText());
                    int disk_5 = Integer.parseInt(disk_size.getText());
                    int arr_5[] = new int[size];
                    int seek_count_5 = 0;
                    int distance_5, cur_track_5;
                    String direction_5 = "right";

                    Vector<Integer> left_5 = new Vector<Integer>(), right_5 = new Vector<Integer>();
                    Vector<Integer> seek_5 = new Vector<Integer>();

                    left_5.add(0);
                    right_5.add(disk_5-1);

                    for (int i=0; i<size; i++) {
                        arr_5[i] = Integer.parseInt(jTable1.getValueAt(i,0).toString());
                        if (arr_5[i] < h_5)
                            left_5.add(arr_5[i]);
                        if (arr_5[i] > h_5)
                            right_5.add(arr_5[i]);
                    }

                    Collections.sort(left_5);
                    Collections.sort(right_5);

                    if (direction_5 == "left") {
                        for (int i = left_5.size() - 1; i >= 0; i--)
                        {
                            cur_track_5 = left_5.get(i);
                            seek_5.add(cur_track_5);
                            distance_5 = Math.abs(cur_track_5 - h_5);
                            seek_count_5 += distance_5;
                            h_5 = cur_track_5;
                        }
                        h_5 = disk_5-1;
                        for (int i = right_5.size() - 1; i >= 0; i--)
                        {
                            cur_track_5 = right_5.get(i);
                            seek_5.add(cur_track_5);
                            distance_5 = Math.abs(cur_track_5 - h_5);
                            seek_count_5 += distance_5;
                            h_5 = cur_track_5;
                        }
                    }
                    else if (direction_5 == "right") {
                        for (int i = 0; i < right_5.size(); i++) 
                        {
                            cur_track_5 = right_5.get(i);
                            seek_5.add(cur_track_5);
                            distance_5 = Math.abs(cur_track_5 - h_5);
                            seek_count_5 += distance_5;
                            h_5 = cur_track_5;
                        }
                        h_5 = 0;
                        for (int i =0; i< left_5.size(); i++) 
                        {
                            cur_track_5 = left_5.get(i);
                            seek_5.add(cur_track_5);
                            distance_5 = Math.abs(cur_track_5 - h_5);
                            seek_count_5 += distance_5;
                            h_5 = cur_track_5;
                        }
                    }

                    seek_count_5+=199;
                    dataset.setValue ("C-SCAN_Right",(Number)seek_count_5);
                } 
                
                //LOOK-Left
                {
                    int h_6 = Integer.parseInt(head.getText());
                    int disk_6 = Integer.parseInt(disk_size.getText());
                    String direction_6 = "left";
                    int arr_6[] = new int[size];
                    int seek_count_6 = 0;
                    int distance_6, cur_track_6;

                    Vector<Integer> left_6 = new Vector<Integer>(), right_6 = new Vector<Integer>();
                    Vector<Integer> seek_6 = new Vector<Integer>();

                    for (int i=0; i<size; i++) {
                        arr_6[i] = Integer.parseInt(jTable1.getValueAt(i,0).toString());
                        if (arr_6[i] < h_6)
                            left_6.add(arr_6[i]);
                        if (arr_6[i] > h_6)
                            right_6.add(arr_6[i]);
                    }

                    Collections.sort(left_6);
                    Collections.sort(right_6);

                    int run_6 = 2;
                    while (run_6-- >0)
                    {
                        if (direction_6 == "left") 
                        {
                            for (int i = left_6.size() - 1; i >= 0; i--) 
                            {
                                cur_track_6 = left_6.get(i);
                                seek_6.add(cur_track_6);
                                distance_6 = Math.abs(cur_track_6 - h_6);
                                seek_count_6 += distance_6;
                                h_6 = cur_track_6;
                            }
                            direction_6 = "right";
                        }
                        else if (direction_6 == "right") 
                        {
                            for (int i = 0; i < right_6.size(); i++) 
                            {
                                cur_track_6 = right_6.get(i);
                                seek_6.add(cur_track_6);
                                distance_6 = Math.abs(cur_track_6 - h_6);
                                seek_count_6 += distance_6;
                                h_6 = cur_track_6;
                            }
                            direction_6 = "left";
                        }
                    }
                    dataset.setValue ("LOOK_Left",(Number)seek_count_6);
                }
                
                //LOOK-Right
                {
                    int h_7 = Integer.parseInt(head.getText());
                    int disk_7 = Integer.parseInt(disk_size.getText());
                    String direction_7 = "right";
                    int arr_7[] = new int[size];
                    int seek_count_7 = 0;
                    int distance_7, cur_track_7;

                    Vector<Integer> left_7 = new Vector<Integer>(), right_7 = new Vector<Integer>();
                    Vector<Integer> seek_7 = new Vector<Integer>();
                    
                    for (int i=0; i<size; i++) {
                        arr_7[i] = Integer.parseInt(jTable1.getValueAt(i,0).toString());
                        if (arr_7[i] < h_7)
                            left_7.add(arr_7[i]);
                        if (arr_7[i] > h_7)
                            right_7.add(arr_7[i]);
                    }

                    Collections.sort(left_7);
                    Collections.sort(right_7);

                    int run_7 = 2;
                    while (run_7-- >0)
                    {
                        if (direction_7 == "left") 
                        {
                            for (int i = left_7.size() - 1; i >= 0; i--) 
                            {
                                cur_track_7 = left_7.get(i);
                                seek_7.add(cur_track_7);
                                distance_7 = Math.abs(cur_track_7 - h_7);
                                seek_count_7 += distance_7;
                                h_7 = cur_track_7;
                            }
                            direction_7 = "right";
                        }
                        else if (direction_7 == "right") 
                        {
                            for (int i = 0; i < right_7.size(); i++) 
                            {
                                cur_track_7 = right_7.get(i);
                                seek_7.add(cur_track_7);
                                distance_7 = Math.abs(cur_track_7 - h_7);
                                seek_count_7 += distance_7;
                                h_7 = cur_track_7;
                            }
                            direction_7 = "left";
                        }
                    }
                    dataset.setValue ("LOOK_Right",(Number)seek_count_7);   
                }
                
                //C-LOOK-Left
                {
                    int h_8 = Integer.parseInt(head.getText());
                    int disk_8 = Integer.parseInt(disk_size.getText());
                    int arr_8[] = new int[size];
                    int seek_count_8 = 0;
                    int distance_8, cur_track_8;
                    String direction_8 = "left";

                    Vector<Integer> left_8 = new Vector<Integer>(), right_8 = new Vector<Integer>();
                    Vector<Integer> seek_8 = new Vector<Integer>();

                    for (int i=0; i<size; i++) {
                        arr_8[i] = Integer.parseInt(jTable1.getValueAt(i,0).toString());
                        if (arr_8[i] < h_8)
                            left_8.add(arr_8[i]);
                        if (arr_8[i] > h_8)
                            right_8.add(arr_8[i]);
                    }

                    Collections.sort(left_8);
                    Collections.sort(right_8);

                    if (direction_8 == "left") {
                        for (int i = left_8.size() - 1; i >= 0; i--)
                        {
                            cur_track_8 = left_8.get(i);
                            seek_8.add(cur_track_8);
                            distance_8 = Math.abs(cur_track_8 - h_8);
                            seek_count_8 += distance_8;
                            h_8 = cur_track_8;
                        }
                        seek_count_8 += abs(h_8 - right_8.get(right_8.size()-1)); 
                        h_8=right_8.get(right_8.size()-1);
                        for (int i = right_8.size() - 1; i >= 0; i--)
                        {
                            cur_track_8 = right_8.get(i);
                            seek_8.add(cur_track_8);
                            distance_8 = Math.abs(cur_track_8 - h_8);
                            seek_count_8 += distance_8;
                            h_8 = cur_track_8;
                        }
                    }
                    else if (direction_8 == "right") {
                        for (int i = 0; i < right_8.size(); i++) 
                        {
                            cur_track_8 = right_8.get(i);
                            seek_8.add(cur_track_8);
                            distance_8 = Math.abs(cur_track_8 - h_8);
                            seek_count_8 += distance_8;
                            h_8 = cur_track_8;
                        }
                        seek_count_8 += abs(h_8 - left_8.get(0)); 
                        h_8=left_8.get(0); 
                        for (int i =0; i< left_8.size(); i++) 
                        {
                            cur_track_8 = left_8.get(i);
                            seek_8.add(cur_track_8);
                            distance_8 = Math.abs(cur_track_8 - h_8);
                            seek_count_8 += distance_8;
                            h_8 = cur_track_8;
                        }
                    }
                    dataset.setValue ("C-LOOK_Left",(Number)seek_count_8);
                }
                
                //C-LOOK-Right
                {
                    int h_9 = Integer.parseInt(head.getText());
                    int disk_9 = Integer.parseInt(disk_size.getText());
                    int arr_9[] = new int[size];
                    int seek_count_9 = 0;
                    int distance_9, cur_track_9;
                    String direction_9 = "right";

                    Vector<Integer> left_9 = new Vector<Integer>(), right_9 = new Vector<Integer>();
                    Vector<Integer> seek_9 = new Vector<Integer>();

                    for (int i=0; i<size; i++) {
                        arr_9[i] = Integer.parseInt(jTable1.getValueAt(i,0).toString());
                        if (arr_9[i] < h_9)
                            left_9.add(arr_9[i]);
                        if (arr_9[i] > h_9)
                            right_9.add(arr_9[i]);
                    }

                    Collections.sort(left_9);
                    Collections.sort(right_9);

                    if (direction_9 == "left") {
                        for (int i = left_9.size() - 1; i >= 0; i--)
                        {
                            cur_track_9 = left_9.get(i);
                            seek_9.add(cur_track_9);
                            distance_9 = Math.abs(cur_track_9 - h_9);
                            seek_count_9 += distance_9;
                            h_9 = cur_track_9;
                        }
                        seek_count_9 += abs(h_9 - right_9.get(right_9.size()-1)); 
                        h_9=right_9.get(right_9.size()-1);
                        for (int i = right_9.size() - 1; i >= 0; i--)
                        {
                            cur_track_9 = right_9.get(i);
                            seek_9.add(cur_track_9);
                            distance_9 = Math.abs(cur_track_9 - h_9);
                            seek_count_9 += distance_9;
                            h_9 = cur_track_9;
                        }
                    }
                    else if (direction_9 == "right") {
                        for (int i = 0; i < right_9.size(); i++) 
                        {
                            cur_track_9 = right_9.get(i);
                            seek_9.add(cur_track_9);
                            distance_9 = Math.abs(cur_track_9 - h_9);
                            seek_count_9 += distance_9;
                            h_9 = cur_track_9;
                        }
                        seek_count_9 += abs(h_9 - left_9.get(0)); 
                        h_9=left_9.get(0); 
                        for (int i =0; i< left_9.size(); i++) 
                        {
                            cur_track_9 = left_9.get(i);
                            seek_9.add(cur_track_9);
                            distance_9 = Math.abs(cur_track_9 - h_9);
                            seek_count_9 += distance_9;
                            h_9 = cur_track_9;
                        }
                    }
                    dataset.setValue ("C-LOOK_Right",(Number)seek_count_9);
                }

                    JFreeChart chart = ChartFactory.createPieChart ("Disk Scheduling",dataset, true, true, true);
                    PiePlot p = (PiePlot) chart.getPlot();
                    ChartFrame frame = new ChartFrame("", chart);
                    frame.setVisible(true);
                    frame.setSize(900, 462);
                    frame.setLocationRelativeTo(null);
                }
            });
        }
    }//GEN-LAST:event_graphActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(sstf.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(sstf.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(sstf.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(sstf.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new sstf().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton add;
    private javax.swing.JButton close;
    private javax.swing.JButton compute;
    private javax.swing.JButton delete;
    private javax.swing.JTextField disk_size;
    private javax.swing.JButton graph;
    private javax.swing.JTextField head;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    private javax.swing.JTextField request;
    private javax.swing.JTextField seek_sequence;
    private javax.swing.JTextField seek_time;
    // End of variables declaration//GEN-END:variables
}
